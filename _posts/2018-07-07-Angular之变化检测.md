---
layout: post
tags: 
    - JavaScript
    - 变化检测
catalog: true
---

当 VM 变更时，如何将其更新到 UI 上面，即如何实现数据绑定的？
Angular 认为视图的更新是由[异步事件]((https://github.com/angular/zone.js/blob/master/STANDARD-APIS.md#browser))的触发引起的，如鼠标交互事件、Ajax 请求、 timer等，那么只需要在异步事件执行完后检查组件视图是否需要更新即可。 

# 几种变化检测的方法
## 数据劫持：getter setter

## 脏检查：zone.js

## 发布订阅模式：Observable, Promise, addEventListener

# ng 1.x 的实现
<button id='run-bi-bind'>运行</button>
<script type='text/javascript'>
document.getElementById('run-bi-bind')
    .addEventListener('click', function() {
        var newWindow = window.open('','双向绑定测试');
        let myCode = document.getElementById('run-bi-bind-code').innerHTML;
        newWindow.document.write(myCode);
    });
</script>

<pre><code id='run-bi-bind-code'>
<div>
    <form>
        <input type="text" ng-bind="count" />
        <button type="button" ng-click="increment" >increment</button>
    </form>
    <div ng-bind="count">
    </div>
</div>
<script>
    function Scope(){
        this.$$watchers=[];         //监听器
    }

    // 监听变化
    Scope.prototype.$watch=function(name,exp,listener){
        this.$$watchers.push({
            name:name,                              //数据变量名
            last:'',                                //数据变量旧值
            newVal:exp,                             //返回数据变量新值的函数
            listener:listener || function(){}       //监听回调函数，变量“脏”时触发
        })
    }

    // 消化脏检测，包括两部分：
    //      监听器 listener 的触发；
    //      VM -> UI 上的更新。
    Scope.prototype.$digest=function(){
        var bindList = document.querySelectorAll("[ng-bind]");      //获取所有含ng-bind的DOM节点
        var dirty=true;
        while(dirty){
            dirty=false;
            for(var i=0;i<this.$$watchers.length;i++){
                var newVal=this.$$watchers[i].newVal();
                var oldVal=this.$$watchers[i].last;

                if(newVal!==oldVal && !isNaN(newVal) && !isNaN(oldVal)){
                    dirty=true;
                    this.$$watchers[i].listener(oldVal,newVal);
                    this.$$watchers[i].last=newVal;
                    for (var j = 0; j < bindList.length; j++) {
                        //获取DOM上的数据变量的名称
                        var modelName=bindList[j].getAttribute("ng-bind");
                        //数据变量名相同的DOM才更新
                        if(modelName==this.$$watchers[i].name) {
                            if (bindList[j].tagName == "INPUT") {
                                //更新input的输入值
                                bindList[j].value = this[modelName];
                            }
                            else {
                                //更新非交互式DOM的值
                                bindList[j].innerHTML = this[modelName];
                            }
                        }
                    }
                }
            }
        }
    };

    window.onload=function(){
        var $scope=new Scope();
        $scope.count=0;
        $scope.increment=function(){
            this.count++;
        };

        //解析ng指令
        var bindList=document.querySelectorAll("[ng-click]");
        for(var i=0;i<bindList.length;i++){
            // 事件绑定
            bindList[i].onclick=(function(index){
                return function() {
                    $scope[bindList[index].getAttribute("ng-click")]();
                    $scope.$digest();           //调用函数时触发$digest
                }
            })(i)
        }

        var inputList=document.querySelectorAll("input[ng-bind]");         
        for(var i=0;i<inputList.length;i++){
            inputList[i].addEventListener("input",(function(index){
                return function(){
                    $scope[inputList[index].getAttribute("ng-bind")]=inputList[index].value;
                    $scope.$digest();           //调用函数时触发$digest
                }
            })(i));
        }

        //绑定数据
        for(var key in $scope){
            if(key!="$$watchers" && typeof $scope[key]!="function") {            //非函数数据才进行绑定
                $scope.$watch(key, (function (index) {
                    return function(){
                        return $scope[index];
                    }
                })(key))
            }
        }

        $scope.$digest();
    };

</script>
</code></pre>

# 参考
[zone.js 包装过的异步事件列表](https://github.com/angular/zone.js/blob/master/STANDARD-APIS.md#browser)<br>
[Angular 2 脏检查过程](https://blog.csdn.net/u011256637/article/details/71056731?utm_source=itdadao&utm_medium=referral)<br>
[Angular变化检测机制：改善的脏检查](https://wufenfen.github.io/2017/07/15/Angular%E5%8F%98%E5%8C%96%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%94%B9%E5%96%84%E7%9A%84%E8%84%8F%E6%A3%80%E6%9F%A5/)<br>
[双向绑定的简单实现 - 基于 “脏检测”](https://juejin.im/entry/5887837d128fe10065f34d0b)<br>
[数据动态绑定的简单实现——基于ES5对象的getter/setter机制](https://zhuanlan.zhihu.com/p/25003235)<br>