---
layout: post
tags: 
    - DP
catalog: true
---

# 动态规划
动态规划和分治法很相似：
- 分治法是指将问题分成一些**独立**的子问题，递归的求解各子问题
- 动态规划适用于这些子问题**不是独立**的情况，也就是各子问题包含公共子问题，通过使用备忘录保存中间结果来避免子问题的重复求值

动态规划和贪心算法：


# 背包问题
用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。

则其状态转移方程便是：dp[i][j] = max(dp[i-1][j-weight[i]]+value[i], dp[i-1][j]) ({i,j|0<i<=N,0<=j<=M})

状态转移分以下几种情况：
- 边界: dp[i][j] = 0, (i = 0 || j = 0)
- 第 i 件比总重大: dp[i][j] = dp[i - 1][j], (weight[i] > W)
- 在放完前 n - 1 件后，第 i 件物品放不下: dp[i][j] = dp[i-1][j]
- 在放完前 n - 1 件后，第 i 件物品放得下: dp[i][j] = dp[i-1][j - weight[i]] + value[i]

边界是：

所以，算法实现如下：
``` js
for(let i=0; i< N; i++) 
    dp[i][0] = 0
for(let j=0; j< M; j++)
    dp[0][j] = 0

for(let i = 1; i < N; i++) {
    for(let j = 0; j< W; j++) {
        if(weight[i] > j)
            dp[i][j] = dp[i-1][j]
        else 
            dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
    }
}
```
